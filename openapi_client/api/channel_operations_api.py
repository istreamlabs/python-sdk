"""
    iStreamPlanet Channels API

    This API provides a way to list, create, and run channels.  Channels consist of inputs (ingest), transcoding settings like codecs and bitrates, and outputs (publishing).  List calls use cursor-based pagination with [RFC 5988](https://tools.ietf.org/html/rfc5988) Link headers. Clients *should* read this header and follow the next link to read all pages of results.   # noqa: E501

    The version of the OpenAPI document: 0.0.0
    Contact: support@istreamplanet.com
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from openapi_client.api_client import ApiClient, Endpoint as _Endpoint
from openapi_client.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from openapi_client.model.error_model import ErrorModel
from openapi_client.model.generic_signal_list import GenericSignalList
from openapi_client.model.insert_metadata_request import InsertMetadataRequest
from openapi_client.model.insert_metadata_result import InsertMetadataResult
from openapi_client.model.program_signal import ProgramSignal
from openapi_client.model.scte35 import Scte35
from openapi_client.model.segment_list import SegmentList
from openapi_client.model.slate import Slate
from openapi_client.model.splice_insert_end_signal import SpliceInsertEndSignal
from openapi_client.model.splice_insert_start_signal import SpliceInsertStartSignal


class ChannelOperationsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.clear_dvr_window_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/dvr-window',
                'operation_id': 'clear_dvr_window',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                },
                'location_map': {
                    'channel_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/problem+json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_signals_endpoint = _Endpoint(
            settings={
                'response_type': (SegmentList,),
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/signal',
                'operation_id': 'get_signals',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                },
                'location_map': {
                    'channel_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json',
                    'application/problem+json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.insert_id3_endpoint = _Endpoint(
            settings={
                'response_type': (InsertMetadataResult,),
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/id3',
                'operation_id': 'insert_id3',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'accept',
                    'insert_metadata_request',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'accept':
                        (str,),
                    'insert_metadata_request':
                        (InsertMetadataRequest,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                    'accept': 'Accept',
                },
                'location_map': {
                    'channel_id': 'path',
                    'accept': 'header',
                    'insert_metadata_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json',
                    'application/problem+json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.insert_scte35_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/scte35',
                'operation_id': 'insert_scte35',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'scte35',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'scte35':
                        (Scte35,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                },
                'location_map': {
                    'channel_id': 'path',
                    'scte35': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/problem+json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.preview_image_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/preview-image',
                'operation_id': 'preview_image',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'accept',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'accept':
                        (str,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                    'accept': 'Accept',
                },
                'location_map': {
                    'channel_id': 'path',
                    'accept': 'header',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/problem+json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.program_end_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/program-end',
                'operation_id': 'program_end',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'program_signal',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'program_signal':
                        (ProgramSignal,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                },
                'location_map': {
                    'channel_id': 'path',
                    'program_signal': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/problem+json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.program_start_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/program-start',
                'operation_id': 'program_start',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'program_signal',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'program_signal':
                        (ProgramSignal,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                },
                'location_map': {
                    'channel_id': 'path',
                    'program_signal': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/problem+json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.signal_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/signal',
                'operation_id': 'signal',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'generic_signal_list',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'generic_signal_list':
                        (GenericSignalList,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                },
                'location_map': {
                    'channel_id': 'path',
                    'generic_signal_list': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/problem+json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.slate_in_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/slate',
                'operation_id': 'slate_in',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'slate',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'slate':
                        (Slate,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                },
                'location_map': {
                    'channel_id': 'path',
                    'slate': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/problem+json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.slate_out_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/slate',
                'operation_id': 'slate_out',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                },
                'location_map': {
                    'channel_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/problem+json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.splice_end_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/splice-end',
                'operation_id': 'splice_end',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'splice_insert_end_signal',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'splice_insert_end_signal':
                        (SpliceInsertEndSignal,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                },
                'location_map': {
                    'channel_id': 'path',
                    'splice_insert_end_signal': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/problem+json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.splice_start_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [
                    'authcode',
                    'm2m'
                ],
                'endpoint_path': '/v2/channels/{channel-id}/splice-start',
                'operation_id': 'splice_start',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'channel_id',
                    'splice_insert_start_signal',
                ],
                'required': [
                    'channel_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'channel_id',
                ]
            },
            root_map={
                'validations': {
                    ('channel_id',): {
                        'max_length': 60,
                        'regex': {
                            'pattern': r'^([a-z0-9]+(-*[a-z0-9]+)*)$',  # noqa: E501
                        },
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'channel_id':
                        (str,),
                    'splice_insert_start_signal':
                        (SpliceInsertStartSignal,),
                },
                'attribute_map': {
                    'channel_id': 'channel-id',
                },
                'location_map': {
                    'channel_id': 'path',
                    'splice_insert_start_signal': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/problem+json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )

    def clear_dvr_window(
        self,
        channel_id,
        **kwargs
    ):
        """Clear DVR Window  # noqa: E501

        Clears the DVR window for the channel by removing all video segments in the manifest from before the request.  This sets the earliest time a player can rewind to this point.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.clear_dvr_window(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.clear_dvr_window_endpoint.call_with_http_info(**kwargs)

    def get_signals(
        self,
        channel_id,
        **kwargs
    ):
        """Get Signals  # noqa: E501

        Returns the active signals for a channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_signals(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SegmentList
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.get_signals_endpoint.call_with_http_info(**kwargs)

    def insert_id3(
        self,
        channel_id,
        **kwargs
    ):
        """Insert ID3  # noqa: E501

        Inserts the provided UTF-8 text metadata in the output stream embedded in a TXXX frame of a ID3 tag.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.insert_id3(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            accept (str): List of accepted Content-Type headers. [optional]
            insert_metadata_request (InsertMetadataRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InsertMetadataResult
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.insert_id3_endpoint.call_with_http_info(**kwargs)

    def insert_scte35(
        self,
        channel_id,
        **kwargs
    ):
        """Insert SCTE-35  # noqa: E501

        Inserts a SCTE-35 formatted binary payload into the channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.insert_scte35(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            scte35 (Scte35): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.insert_scte35_endpoint.call_with_http_info(**kwargs)

    def preview_image(
        self,
        channel_id,
        **kwargs
    ):
        """Get Preview Image  # noqa: E501

        Get a static image of what your channel is outputting.  Valid Accept headers are: image/jpeg  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.preview_image(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            accept (str): List of accepted Content-Type headers. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.preview_image_endpoint.call_with_http_info(**kwargs)

    def program_end(
        self,
        channel_id,
        **kwargs
    ):
        """Program End  # noqa: E501

        Inserts a 'program end' SCTE-35 message into the channel.  This route should only be used for non-overlapping program markers.  If you want overlapping program makers please use Generic Signal instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.program_end(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            program_signal (ProgramSignal): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.program_end_endpoint.call_with_http_info(**kwargs)

    def program_start(
        self,
        channel_id,
        **kwargs
    ):
        """Program Start  # noqa: E501

        Inserts a 'program start' SCTE-35 message into the channel.  This route should only be used for non-overlapping program markers.  If you want overlapping program makers please use Generic Signal instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.program_start(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            program_signal (ProgramSignal): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.program_start_endpoint.call_with_http_info(**kwargs)

    def signal(
        self,
        channel_id,
        **kwargs
    ):
        """Generic Signal  # noqa: E501

        Inserts a SCTE-35 message into the channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.signal(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            generic_signal_list (GenericSignalList): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.signal_endpoint.call_with_http_info(**kwargs)

    def slate_in(
        self,
        channel_id,
        **kwargs
    ):
        """Slate in  # noqa: E501

        Replaces the current video source with a slate image or video.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.slate_in(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            slate (Slate): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.slate_in_endpoint.call_with_http_info(**kwargs)

    def slate_out(
        self,
        channel_id,
        **kwargs
    ):
        """Slate out  # noqa: E501

        Removes any active slate and show the source video content.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.slate_out(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.slate_out_endpoint.call_with_http_info(**kwargs)

    def splice_end(
        self,
        channel_id,
        **kwargs
    ):
        """Splice Insert End  # noqa: E501

        Inserts a 'splice insert end' SCTE-35 message into the channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.splice_end(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            splice_insert_end_signal (SpliceInsertEndSignal): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.splice_end_endpoint.call_with_http_info(**kwargs)

    def splice_start(
        self,
        channel_id,
        **kwargs
    ):
        """Splice Insert Start  # noqa: E501

        Inserts a 'splice insert start' SCTE-35 message into the channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.splice_start(channel_id, async_req=True)
        >>> result = thread.get()

        Args:
            channel_id (str): Unique channel identifier

        Keyword Args:
            splice_insert_start_signal (SpliceInsertStartSignal): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['channel_id'] = \
            channel_id
        return self.splice_start_endpoint.call_with_http_info(**kwargs)

